<?php
/*
Copyright (c) 2008 Paolo Ermani (SoftWUD) (email: softwud@softwud.com)

This file is part of the Page Blocks WordPress plugin.

The Page Blocks plugin is free software: you can redistribute it and / or modify
it under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but	WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the	GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.
*/

if ((preg_match('#' . basename(__FILE__) . '#', $_SERVER['PHP_SELF'])) ||
	(!defined('PBS_PLUGIN')))
{
	exit;
}

if (!class_exists("PageBlocks"))
{
	/**
	 * Template function for WordPress prior to version 2.8
	 *
	 * If you are still running a version of WordPress prior to version 2.8,
	 * this function needs to be placed inside your page template file usually
	 * called page.php. This function identifies the main loop to the plugin.
	 * The Page Blocks plugin will ignore any other loops it encounters.
	 *
	 * The call to this function needs to be placed just before the main
	 * WordPress loop as shown in the example below:
	 *
	 * <?php
	 * page_blocks_loop();  // <--- Place it here
	 * if (have_posts())
	 * {
	 *     while (have_posts())
	 *     {
	 *         ...
	 *     }
	 * }
	 * ?>
	 */
	function page_blocks_loop()
	{
		global $page_blocks;
		if (isset($page_blocks))
		{
			$page_blocks->in_main_loop = true;
		}
	}

	// Class definition
	class PageBlocks
	{
		// Class Constants
		var $plugin_version = '1.1.0';
		var $class_version = '2.0';
		var $db_version = '1.0';
		var $db_table;	// Initialised by the class constructor
		var $debug_level = 0;

		// Global WordPress v2.3.3 post variables to be saved
		var $wp_post_vars_233 =
			array('post', 'id', 'postdata', 'authordata', 'day', 'currentmonth',
				  'page', 'pages', 'multipage', 'more', 'numpages', 'wp_query',
				  'pagenow');

		// Global WordPress v2.5+ post variables to be saved
		var $wp_post_vars_25 =
			array('post', 'id', 'authordata', 'day', 'currentmonth', 'page',
				  'pages', 'multipage', 'more', 'numpages');

		// Default values to be inserted into the plugin page configuration
		// database table when setting up blocks on a page for the first time
		var $page_config_default_values =
			array('id'					=>	0,
				  'page_id'				=>	0,
				  'top_left'			=>	0,
				  'top_left_style'		=>	'',
				  'top_right'			=>	0,
				  'top_right_style'		=>	'',
				  'bottom_left'			=>	0,
				  'bottom_left_style'	=>	'',
				  'bottom_right'		=>	0,
				  'bottom_right_style'	=>	'',
				  'widgets'				=>	'');

		// Information about the WordPress sidebars registered by the plugin
		var $page_blocks_sidebars_info =
			array('top_left_name'		=>	'Top Left Page Block',
				  'top_left_id'			=>	'pbs-sidebar-top-left',
				  'top_right_name'		=>	'Top Right Page Block',
				  'top_right_id'		=>	'pbs-sidebar-top-right',
				  'bottom_left_name'	=>	'Bottom Left Page Block',
				  'bottom_left_id'		=>	'pbs-sidebar-bottom-left',
				  'bottom_right_name'	=>	'Bottom Right Page Block',
				  'bottom_right_id'		=>	'pbs-sidebar-bottom-right');

		// Class fields
		var $page_config = NULL;
		var $in_main_loop = false;
		var $wp_post_vars = array();

		// Private member field for providing a static storage space for all the
		// ids of all the sidebars registered by register_page_blocks() thus far
		// as a workaround so they can be removed. Although unregister_sidebar()
		// is documented as allowing a reference to a sidebar by the "name",
		// this in fact is the "id" and not the "name")
		var $registered_sidebars_ids = array();

		// Class methods

		/**
		 * PageBlocks class constructor
		 *
		 * Creates an instance of the PageBlocks class completely initialised
		 */
		function PageBlocks()
		{
			global $wpdb;
			
			// Initialise the class constants / fields whose values are the
			// result of a non-constant expression
//			$this->db_table = $wpdb->prefix . 'page_blocks';
			$this->db_table = $wpdb->prefix . 'pageblocks_pages_config';
			$this->page_config_default_values['widgets'] =
				maybe_serialize(array('array_version' => 3));
			$this->wp_post_vars = ($this->is_wordpress_version('2.5', '<')) ?
								   $this->wp_post_vars_233 :
								   $this->wp_post_vars_25;
			$this->debug_level = get_option(PBS_OPTION_DEBUG_LEVEL, 0);
		}

		/**
		 * Ensures that the stylesheet used by the plugin is included on all
		 * pages generated by WordPress.
		 */
		function enqueue_styles_and_scripts()
		{
			wp_enqueue_style(PBS_PLUGIN_ID,
							 PBS_STYLESHEET_URL . '/page_blocks.css',
							 false, $this->plugin_version, 'screen');
			$this->debug('Stylesheet enqueued');
		}

		/**
		 * Deprecated function for sending the Page Blocks stylesheet to the
		 * browser (only required for WordPress versions prior to 2.7)
		 */
		function output_page_blocks_header()
		{
?>
<link href="<?php echo PBS_STYLESHEET_URL . '/page_blocks.css'; ?>" rel="stylesheet" type="text/css" media="screen">
<?php
		}

		/**
		 * Generates widget HTML content at the start of the main WordPress loop
		 *
		 * @param WP_Query $loop_query The instance of WP_Query that is being
		 * used for the current loop (only for WordPress v2.8+)
		 */
		function insert_page_blocks_top(&$loop_query = NULL)
		{
			$this->debug('Generating TOP page blocks ...');

			if (!function_exists('dynamic_sidebar'))
			{
				// Widget functionality is not available so bail out
				$this->debug('Exiting - Sidebars not supported');
				return;
			}

			// Check whether the top page blocks should be generated
			if (!$this->should_insert_blocks($loop_query))
			{
				$this->debug('Exiting - No reason to generate page blocks');
				return;
			}

			// Flag that this is the main loop 
			$this->in_main_loop = true;

			// Find the ID of the page being displayed in order to find the
			// corresponding page configuration information
			$page_id = $this->determine_page_id();
			if ($page_id < 1)
			{
				$this->debug('Exiting - Page ID is not valid');
			}

			$this->debug('Page ID is:', $page_id);

			// Save the current page's post information (if necessary)
			$post_backup = array();
			if ($this->is_wordpress_version('2.8', '<'))
			{
			    // In versions of WordPress prior to v2.8 the the_post()
			    // WP_Query method would call setup_post_data() before calling
			    // any 'loop_start' action handlers, so this data needs is saved
				// before getting the widgets to generate their output as a
				// safety pre-caution
				$post_backup = $this->backup_post_data();
				$this->debug('Post data backed up for restoration later',
							 $post_backup);
			}

			// Find the configuration information for the page being displayed
			// and store it for later use in insert_page_blocks_bottom() at the
			// end of the loop
			$page_config =
				$this->page_config = $this->get_page_config($page_id);
			if ($page_config === false)
			{
				// No page configuration found so bail out
				$this->debug('Exiting - Configuration information not found');
				return;
			}

			$this->debug('Page configuration found:', $page_config);

			// Register the sidebars that should be displayed
			if (!$this->register_page_blocks($page_config))
			{
				// No sidebars can be registered so bail out
				$this->debug('Unable to register page blocks sidebars');
				return;
			}

			// Attempt to generate the contents of the blocks, capturing the
			// output in a buffer in case there is something to output so it can
			// be enclosed within an appropriate HTML container
			$block = '';
			$sidebars = $this->page_blocks_sidebars_info;

			if ($this->is_wordpress_version('2.7.1', '>'))
			{
			    // Hack required to force the wp_get_sidebars_widgets() function
			    // to re-load all the sidebar widgets instead of getting them
			    // from the (potentially modified) cache. This is only required
			    // for WordPress v2.8 or later (so far)
				global $_wp_sidebars_widgets;
				$_wp_sidebars_widgets = array();
			}

			ob_start();
			$block_rendered = dynamic_sidebar($sidebars['top_left_name']);
			$left_block = ob_get_clean();

			if ($block_rendered)
			{
				$left_block = '<ul id="pbs_top_left" style="' .
							  $page_config['top_left_style'] . '">' .
							  $left_block . '</ul>';
				$this->debug('TOP LEFT page block contents generated');
			}

			ob_start();
			$block_rendered = dynamic_sidebar($sidebars['top_right_name']);
			$right_block = ob_get_clean();

			if ($block_rendered)
			{
				$right_block = '<ul id="pbs_top_right" style="' .
							   $page_config['top_right_style'] . '">' .
							   $right_block . '</ul>';
				$this->debug('TOP RIGHT page block contents generated');
			}

			if (($left_block != '') || ($right_block != ''))
			{
				$block = '<div class="pbs_clearfix">' .
						 $left_block . $right_block .
						 '</div>';
			}

			// Send the complete page blocks content to the browser
			echo $block;

			// Restore the global post variables so that the page contents are
			// displayed correctly inside the loop (only required for WordPress
			// versions prior to v2.8
			if ($this->is_wordpress_version($wp_version, '2.8', '<'))
			{
				$this->restore_post_data($post_backup);
				$this->debug('Restored post data');
			}

			$this->debug('Finished TOP page blocks.');
		}

		/**
		 * Generates widget HTML content at the end of the main WordPress loop
		 */
		function insert_page_blocks_bottom(&$loop_query = NULL)
		{
			$this->debug('Generating BOTTOM page blocks ...');

			if (!function_exists('dynamic_sidebar'))
			{
				// Widget functionality is not available so bail out
				$this->debug('Exiting - Sidebars not supported');
				return;
			}

			// Check whether the bottom page blocks should be generated
			if (!$this->should_insert_blocks($loop_query))
			{
				$this->debug('Exiting - No reason to generate page blocks');
				return;
			}

			// Save the current page's post information
			$post_backup = $this->backup_post_data();
			$this->debug('Post data backed up for restoration later',
						 $post_backup);

			// Get the configuration information for the page being displayed
			$page_config = $this->page_config;
			if ($page_config === false)
			{
				// No page configuration found so bail out
				$this->debug('Exiting - Configuration information not found');
				return;
			}

			// Attempt to generate the contents of the blocks, capturing the
			// output in a buffer in case there is something to output so it can
			// be enclosed within an appropriate HTML container
			$block = '';
			$sidebars = $this->page_blocks_sidebars_info;

			if ($this->is_wordpress_version('2.7.1', '>'))
			{
			    // Hack required to force the wp_get_sidebars_widgets() function
			    // to re-load all the sidebar widgets instead of getting them
			    // from the (potentially modified) cache. This is only required
			    // for WordPress v2.8 or later (so far)
				global $_wp_sidebars_widgets;
				$_wp_sidebars_widgets = array();
			}

			ob_start();
			$block_rendered = dynamic_sidebar($sidebars['bottom_left_name']);
			$left_block = ob_get_clean();

			if ($block_rendered)
			{
				$left_block = '<ul id="pbs_bottom_left" style="' .
							  $page_config['bottom_left_style'] . '">' .
							  $left_block . '</ul>';
				$this->debug('BOTTOM LEFT page block contents generated');
			}

			ob_start();
			$block_rendered = dynamic_sidebar($sidebars['bottom_right_name']);
			$right_block = ob_get_clean();

			if ($block_rendered)
			{
				$right_block = '<ul id="pbs_bottom_right" style="' .
							   $page_config['bottom_right_style'] . '">' .
							   $right_block . '</ul>';
				$this->debug('BOTTOM RIGHT page block contents generated');
			}

			if (($left_block != '') || ($right_block != ''))
			{
				$block = '<div class="pbs_clearfix">' .
						 $left_block . $right_block .
						 '</div>';
			}

			// Send the complete page blocks content to the browser
			echo $block;

			// Restore the global post variables so that they contain the same
			// values after the loop as they did during the loop
			$this->restore_post_data($post_backup);
			$this->debug('Restored post data');

			// Reset the pre-WordPress v2.8 main loop indicator
			$this->in_main_loop = false;

			$this->debug('Finished BOTTOM page blocks.');
		}

		/**
		 * Determines whether page blocks should be generated
		 */
		function should_insert_blocks(&$loop_query)
		{
			$page_post = NULL;

			// First check that this is the main WordPress query
			global $wp_version;
			if (version_compare($wp_version, '2.7.1', '>'))
			{
				global $wp_the_query;
				if ($loop_query !== $wp_the_query)
				{
					// Don't display any page blocks on custom WordPress queries
					$this->debug('Exiting - This is not the main loop');
					return false;
				}

				// Retrieve the information for the first post (i.e. the page)
				$page_post = $loop_query->posts[0];
			}
			else
			{
				if (!$this->in_main_loop)
				{
					// Since it isn't possible to determine whether the current
					// WordPress loop is the main loop for WordPress versions
					// prior to v2.8, don't display any page blocks unless the
					// the page_blocks_loop() template function has been used to
					// flag this loop as the main loop
					$this->debug('Exiting - This is not the main loop');
					return false;
				}

				global $post;
				$page_post = $post;
			}

			$this->debug('Contents of WordPress Post:', $page_post);

			// Check if this is a supported type of page post
			if (is_page())
			{
				// Is this a page that displays only a single post, an archive
				// of posts, the search form, or the file not found page ?
				if (is_single() || is_archive() || is_search() || is_404())
				{
					// We don't display any page blocks on these types of pages
					$this->debug('Not a supported page type');
					return false;
				}

				// Otherwise make sure that the page isn't password protected,
				// and if it is then ensure the correct password has been passed
				if (!empty($page_post->post_password))
				{
				    $pass = stripslashes($_COOKIE['wp-postpass_' . COOKIEHASH]);
					if ($pass != $page_post->post_password)
					{
						// Password doesn't match
						$this->debug('Post password does not match ',
									 "entered password '", $pass, "'");
						return false;
					}
					else
					{
						// Password matches
						$this->debug('Passwords match');
					}
				}
 				else
				{
					// No password has been set
					$this->debug('No post password set');
				}
			}
			else
			{
				// This isn't a page so we don't need to display any page blocks
				$this->debug('Not a supported page type');
				return false;
			}

			// All the test criteria are met so show the page blocks
			$this->debug('Ok to generate page blocks');
			return true;
		}

		/**
		 * Installer for the plugin
		 */
		function admin_install_page_blocks()
		{
			global $wpdb;

			if ($this->is_debug_mode())
			{
				if (is_writable(PBS_PLUGIN_PATH))
				{
					// Create a new log file, or truncate an existing one
					$msg = 'Plugin activation ' .
						   date('l jS F Y \a\\t H:i:s O');
					$this->write_to_log(PBS_DEBUG_LOG, $msg, true, true);
				}
				else
				{
					$msg = 'The Page Blocks plugin directory must have write ' .
						   'permissions for debugging. No debug log will be ' .
						   'created until the permissions are fixed';
					$this->admin_add_user_msg(PBS_MSG_WARNING, $msg);
				}
			}

			$this->admin_add_user_msg(PBS_MSG_GENERAL,
									  'Activating the Page Blocks plugin...');

			// Load in the dbDelta() function for upgrading the database
			// (if required)
			require_once(PBS_WP_UPGRADE_FUNCTIONS);

			$installed = $this->get_plugin_setting(PBS_OPTION_SETTINGS,
												   PBS_SETTING_DB_VERSION,
												   'None');

			// Code required for upgrade from v1.0.3 to v1.1.0 (once off)
			if ($installed == 'None')
			{
				$old_installed = get_option('pbs_db_version');
				if ($old_installed != '')
				{
					$this->debug('Attempting to cleanup database while ' .
								 'upgrading plugin to version 1.1.0');

					// When upgrading from plugin v1.0.3 to v1.1.0 need to
					// clean up the WordPress options table
					$installed = $old_installed;
					delete_option('pbs_db_version');
					delete_option('pbs_db_tablename');
					delete_option('pageblocks_admin_options');
				}
			}

			$required = $this->db_version;
			$this->debug('Current plugin database version: ', $installed);
			$this->debug('Required plugin database version:', $required);

			$sql = "CREATE TABLE " . $this->db_table . " (
				   id INT UNSIGNED NOT NULL AUTO_INCREMENT,
				   page_id INT UNSIGNED NOT NULL,
				   top_left TINYINT UNSIGNED NOT NULL DEFAULT " .
				   $this->page_config_default_values['top_left'] . ",
				   top_left_style VARCHAR(255) NOT NULL DEFAULT '" .
				   $this->page_config_default_values['top_left_style'] . "',
				   top_right TINYINT UNSIGNED NOT NULL DEFAULT " .
				   $this->page_config_default_values['top_right'] . ",
				   top_right_style VARCHAR(255) NOT NULL DEFAULT '" .
				   $this->page_config_default_values['top_right_style'] . "',
				   bottom_left TINYINT UNSIGNED NOT NULL DEFAULT " .
				   $this->page_config_default_values['bottom_left'] . ",
				   bottom_left_style VARCHAR(255) NOT NULL DEFAULT '" .
				   $this->page_config_default_values['bottom_left_style'] . "',
				   bottom_right TINYINT UNSIGNED NOT NULL DEFAULT " .
				   $this->page_config_default_values['bottom_right'] . ",
				   bottom_right_style VARCHAR(255) NOT NULL DEFAULT '" .
				   $this->page_config_default_values['bottom_right_style'] . "',
				   widgets LONGTEXT NOT NULL DEFAULT '',
				   UNIQUE KEY id (id)
				   );";

			$show_tables_sql = "SHOW TABLES LIKE '$this->db_table'";
			if ($wpdb->get_var($show_tables_sql) != $this->db_table)
			{
				// Table doesn't exist yet so create it
				$msg = "Creating the '{$this->db_table}' table";
				$this->admin_add_user_msg(PBS_MSG_GENERAL, $msg);
				$this->debug($msg);

				$sql_actions = dbDelta($sql);
				$this->debug('Actions carried out by WordPress', $sql_actions);
			}
			else if ($installed != $required)
			{
				// Table exists but it's not the same version as the one
				// required for this version of the plugin
				$msg = "Updating the '{$this->db_table}' table to " .
					   "version '{$this->db_version}'";
				$this->admin_add_user_msg(PBS_MSG_GENERAL, $msg);
				$this->debug($msg);

				$sql_actions = dbDelta($sql);
				$this->debug('Actions carried out by WordPress', $sql_actions);
			}

			$activated = false;
			if ($wpdb->get_var($show_tables_sql) != $this->db_table)
			{
				// The required table wasn't created so notify the user
				$msg = "Unable to create the '{$this->db_table}' table";
				$this->admin_add_user_msg(PBS_MSG_ERROR, $msg);
				$this->debug($msg);
			}
			else
			{
				$activated = true;
			}

			if ($activated)
			{
				// Set up the required plugin settings
				$this->set_plugin_setting(PBS_SETTING_DB_VERSION,
										  $this->db_version);

				// Set the currently selected page
				$this->set_plugin_setting(PBS_SETTING_SELECTED_PAGE, -1);

				// Don't overwrite the current debug level if it exists,
				// otherwise set it to the default "no debugging" level 0
				if ($this->get_plugin_setting(PBS_OPTION_DEBUG_LEVEL) === '')
				{
					update_option(PBS_OPTION_DEBUG_LEVEL, 0);
				}

				$msg = 'The Page Blocks plugin was successfully activated.';
				$this->admin_add_user_msg(PBS_MSG_SUCCESS, $msg);
				$this->debug($msg);
			}
			else
			{
				$msg = 'Page Blocks plugin activation failed.';
				$this->admin_add_user_msg(PBS_MSG_ERROR, $msg);
				$this->debug($msg);
			}
		}

		/**
		 * Add a message to the messages displayed to the user on activation
		 */
		function admin_add_user_msg($type, $text)
		{
			switch ($type)
			{
				case PBS_MSG_ERROR:
				case PBS_MSG_WARNING:
				case PBS_MSG_SUCCESS:
				case PBS_MSG_GENERAL:
					$message_text = $type . $text;
					break;

				default:
					$message_text = PBS_MSG_GENERAL . $text;
					break;
			}

			$current = get_option(PBS_OPTION_ADMIN_MSG);
			if (is_array($current))
			{
				// Other message texts have already been added previously
				$current[] = $message_text;
			}
			else
			{
				$current = array();
				$current[] = $message_text;
			}

			update_option(PBS_OPTION_ADMIN_MSG, $current);

			return true;
		}

		/**
		 * Outputs messages to the user on the WordPress Plugins admin page
		 */
		function admin_show_messages()
		{
			$message = get_option(PBS_OPTION_ADMIN_MSG);
			if (is_array($message))
			{
				$message = join('<br />', $message);
			}

			$message = trim($message);
			if (empty($message))
			{
				// Bail out if there are no messages to show
				return;
			}

			echo '<div id="pbs_message" class="error fade"><p>' .
				 $message . '</p></div>';

			update_option(PBS_OPTION_ADMIN_MSG, array());
			update_option(PBS_OPTION_ADMIN_PREV_MSG, $message);
		}

		/**
		 * Uninstaller for the plugin
		 */
		function admin_uninstall_page_blocks()
		{
			delete_option(PBS_OPTION_ADMIN_MSG);
			delete_option(PBS_OPTION_ADMIN_PREV_MSG);
			$this->debug('The Page Blocks plugin was deactivated.');
		}

		/**
		 * Saves the selected page's ID if changed on the WordPress Widgets
		 * admin page
		 */
		function admin_process_widget_page_change()
		{
			$new_page_id = (int)
				$this->get_post_field('page-blocks-selected-page-id', -1);

			if (($this->get_post_field('page-blocks-submit') != '') &&
				($new_page_id > 0))
			{
				$this->set_plugin_setting(PBS_SETTING_SELECTED_PAGE,
										  $new_page_id);
				$this->debug('Updated selected page setting to page ID',
							 $new_page_id);
			}
		}

		/**
		 * Function to safely parse POSTed variables
		 */
		function get_post_field($name, $default = '')
		{
			$value = isset($_POST[$name]) ? $_POST[$name] : $default;
			return $value;
		}

		/**
		 * Retrieves plugin configuration values
		 */
		function get_plugin_setting($option_name, $setting_name = NULL,
									$default = '')
		{
			if ((!is_string($option_name)) || (empty($option_name)) ||
				($default === false))
			{
				$this->debug('WARNING: get_plugin_setting() used incorrectly');
				return false;
			}

			$settings = get_option($option_name);
			$setting = $default;

		    if (is_array($settings))
		    {
		    	if ((!is_null($setting_name)) &&
					(array_key_exists($setting_name, $settings)))
		    	{
			        $setting = $settings[$setting_name];
			    }
			    else if (is_null($setting_name))
			    {
			    	$setting = $settings;
			    }
		    }
		    else if (is_null($setting_name))
		    {
		    	$setting = $settings;
		    }

			return $setting;
		}

		/**
		 * Stores plugin configuration values
		 */
		function set_plugin_setting($setting_name, $setting_value)
		{
			$settings = get_option(PBS_OPTION_SETTINGS);
			$settings[$setting_name] = $setting_value;

			update_option(PBS_OPTION_SETTINGS, $settings);
		}

		/**
		 * Ensures that the stylesheet and javascript code used by the plugin on
		 * the WordPress admin pages is included.
		 */
		function admin_enqueue_styles_and_scripts()
		{
			wp_enqueue_style(PBS_PLUGIN_ID,
							 PBS_STYLESHEET_URL . '/page_blocks.css',
							 false, $this->plugin_version, 'screen');
			wp_enqueue_script(PBS_PLUGIN_ID,
							  PBS_SCRIPTS_URL . '/page_blocks.js',
							  false, $this->plugin_version);
		}

		/**
		 * Ensures that the page block sidebars for the selected page are
		 * available on the WordPress Widgets admin page
		 */
		function admin_register_page_blocks()
		{
			if (!function_exists('register_sidebar'))
			{
				// Sidebar functionality is not available so abort here
				$this->debug('Exiting - Sidebars not supported');
				return;
			}

			// First get the page ID.
			$page_id =
				(int) $this->get_plugin_setting(PBS_OPTION_SETTINGS,
												PBS_SETTING_SELECTED_PAGE);
			if ($page_id < 1)
			{
				// The site administrator hasn't configured the plugin
				// yet so bail out
				$this->debug('Exiting - No page selected on widgets admin');
				return;
			}

			$page_config = 
				$this->page_config = $this->get_page_config($page_id);
			if ($page_config === false)
			{
				// No page configuration can be found so bail out
				$this->debug('Exiting - Configuration information not found');
				return;
			}

			if (!$this->register_page_blocks($page_config))
			{
				$this->debug('Unable to register page blocks');
				return;
			}
		}

		/**
		 * Registers callbacks that display the page selection dropdown on the
		 * WordPress Widgets admin page
		 */
		function admin_register_page_blocks_widget_panel()
		{
			// Add an action to initialise the widget panel
			add_action('sidebar_admin_setup',
					   array(&$this, 'admin_widget_page_blocks_setup'), 0);

			// Add an action to display the widget panel
			add_action('sidebar_admin_page',
					   array(&$this, 'admin_widget_page_blocks_page'), 0);

			$this->debug('Registered callbacks for displaying page ' .
						 'selection dropdown');
		}

		/**
		 * Callback method for initialising the page selection dropdown
		 */
		function admin_widget_page_blocks_setup()
		{
			// Nothing required here
		}

		/**
		 * Callback method for generating the drop down form to the Widgets
		 * admin page
		 */
		function admin_widget_page_blocks_page()
		{
			$page_id =
				(int) $this->get_plugin_setting(PBS_OPTION_SETTINGS,
												PBS_SETTING_SELECTED_PAGE);

			// Create the HTML for the page selection dropdown
			$pages = wp_dropdown_pages(
				array('selected' => $page_id,
					  'name' => 'page-blocks-selected-page-id',
					  'show_option_none' => 'No Page Selected',
					  'echo' => 0));
			$new_pages = substr($pages, 0, 8) .
						 'style="vertical-align: middle;" ' .
						 substr($pages, 8);

			// Display the HTML form
?>
	<div class="wrap">
		<form id="pbs_widgets_page_select" method="post">
			<h2><?php _e('Page Blocks Widgets'); ?></h2>
			<p><?php _e('Select page to edit: '); ?>&nbsp;<?php echo $new_pages; ?><span class="submit" style="vertical-align: middle;"><input type="submit" name="page-blocks-submit" value="<?php _e('Select'); ?>" /></span></p>
		</form>
	</div>
<?php
		}

		function admin_register_settings_menu()
		{
			add_submenu_page('options-general.php',
							 'Page Blocks Page Settings', 'Page Blocks',
							 'administrator', 'page_blocks_settings',
							 array(&$this, 'admin_page_blocks_settings_page')); 
		}

		function admin_page_blocks_settings_page()
		{
			$pages = get_pages();
?>
<div class="wrap">
	<h2>Page Blocks Page Settings</h2>
	<form method="post" action="options.php">
<?php
			if (function_exists('settings_fields'))
			{
				settings_fields('page-blocks-settings');
			}
			else
			{
				wp_nonce_field('update-options');
?>
		<input type="hidden" name="action" value="update" />
		<input type="hidden" name="page_options" value="top_left, top_left_style, top_right, top_right_style, bottom_left, bottom_left_style, bottom_right, bottom_right_style" />
<?php
			}
?>
		<table class="widefat" cellspacing="0">
			<thead>
				<tr>
					<th scope="col">ID</th>
					<th scope="col">Title</th>
					<th scope="col">Slug</th>
					<th scope="col">Top Left</th>
					<th scope="col">Top Right</th>
					<th scope="col">Bottom Left</th>
					<th scope="col">Bottom Right</th>
				</tr>
			</thead>
			<tfoot>
				<tr>
					<th scope="col">ID</th>
					<th scope="col">Title</th>
					<th scope="col">Slug</th>
					<th scope="col">Top Left</th>
					<th scope="col">Top Right</th>
					<th scope="col">Bottom Left</th>
					<th scope="col">Bottom Right</th>
				</tr>
			</tfoot>
			<tbody class="list:post">
<?php
			if (count($pages) > 0)
			{
				foreach ($pages as $page)
				{
					$page_config = $this->get_page_config($page->ID);
					if ($page_config === false)
					{
						// No page configuration can be found so use
						// default values
						$page_config = $this->page_config_default_values;
						$this->debug('Using default values for page ' .
									 'configuration of page ID', $page_id);
					}
					$pid = $page->ID;
?>
				<tr valign="top">
					<td scope="col"><?php echo $pid; ?></td>
					<td scope="col"><?php echo $page->post_title; ?></td>
					<td scope="col"><?php echo $page->post_name; ?></td>

					<td scope="col"><input type="checkbox" name="tl_chk<?php echo $pid; ?>" id="tl_chk<?php echo $pid; ?>" value="" <?php echo ($page_config['top_left'] == '1') ? 'checked="checked"' : ''; ?> onClick="set_value('top_left<?php echo $pid; ?>', 'tl_chk<?php echo $pid; ?>');" /> <input type="text" name="top_left_style[<?php echo $pid; ?>]" value="<?php echo $page_config['top_left_style']; ?>" /><input type="hidden" name="top_left[<?php echo $pid; ?>]" id="top_left<?php echo $pid; ?>" value="<?php echo $page_config['top_left']; ?>" /></td>

					<td scope="col"><input type="checkbox" name="tr_chk<?php echo $pid; ?>" id="tr_chk<?php echo $pid; ?>" value="" <?php echo ($page_config['top_right'] == '1') ? 'checked="checked"' : ''; ?> onClick="set_value('top_right<?php echo $pid; ?>', 'tr_chk<?php echo $pid; ?>');" /> <input type="text" name="top_right_style[<?php echo $pid; ?>]" value="<?php echo $page_config['top_right_style']; ?>" /><input type="hidden" name="top_right[<?php echo $pid; ?>]" id="top_right<?php echo $pid; ?>" value="<?php echo $page_config['top_right']; ?>" /></td>

					<td scope="col"><input type="checkbox" name="bl_chk<?php echo $pid; ?>" id="bl_chk<?php echo $pid; ?>" value="" <?php echo ($page_config['bottom_left'] == '1') ? 'checked="checked"' : ''; ?> onClick="set_value('bottom_left<?php echo $pid; ?>', 'bl_chk<?php echo $pid; ?>');" /> <input type="text" name="bottom_left_style[<?php echo $pid; ?>]" value="<?php echo $page_config['bottom_left_style']; ?>" /><input type="hidden" name="bottom_left[<?php echo $pid; ?>]" id="bottom_left<?php echo $pid; ?>" value="<?php echo $page_config['bottom_left']; ?>" /></td>

					<td scope="col"><input type="checkbox" name="br_chk<?php echo $pid; ?>" id="br_chk<?php echo $pid; ?>" value="" <?php echo ($page_config['bottom_right'] == '1') ? 'checked="checked"' : ''; ?> onClick="set_value('bottom_right<?php echo $pid; ?>', 'br_chk<?php echo $pid; ?>');" /> <input type="text" name="bottom_right_style[<?php echo $pid; ?>]" value="<?php echo $page_config['bottom_right_style']; ?>" /><input type="hidden" name="bottom_right[<?php echo $pid; ?>]" id="bottom_right<?php echo $pid; ?>" value="<?php echo $page_config['bottom_right']; ?>" /></td>
				</tr>
<?php
				}
			}
			else
			{
?>
				<tr valign="top">
					<td colspan="7">No Pages Defined</td>
				</tr>
<?php
			}
?>
			</tbody>
		</table>
<?php
			if (count($pages) > 0)
			{
?>
		<p><input type="submit" class="button-primary" value="<?php _e('Save All Changes') ?>" /></p>
<?php
			}
?>
	</form>
</div>
<?php
		}

		function admin_register_page_blocks_settings()
		{
			if (function_exists('register_setting'))
			{
				register_setting('page-blocks-settings', 'top_left');
				register_setting('page-blocks-settings', 'top_left_style');
				register_setting('page-blocks-settings', 'top_right');
				register_setting('page-blocks-settings', 'top_right_style');
				register_setting('page-blocks-settings', 'bottom_left');
				register_setting('page-blocks-settings', 'bottom_left_style');
				register_setting('page-blocks-settings', 'bottom_right');
				register_setting('page-blocks-settings', 'bottom_right_style');
			}
		}

		function update_option_top_left($new_values, $old_value)
		{
			global $wpdb;

			foreach ($new_values as $page_id => $new_value)
			{
				$page_config = $this->get_page_config($page_id);
				if ($page_config === false)
				{
					// No page configuration can be found so use default values
					$page_config = $this->page_config_default_values;
					$this->debug('Using default values for page ' .
								 'configuration of page ID', $page_id);
				}

				$page_config['page_id'] = $page_id;

				$top_left = intval($wpdb->escape($new_value));
				$page_config['top_left'] = $top_left;

				// Save the values into the database
				if (!$this->update_page_config($page_id, $page_config))
				{
					$this->debug('Unable to update the top left value for ' .
								 'page ID', $page_id);
				}
			}

			return $old_value;
		}

		function update_option_top_left_style($new_values, $old_value)
		{
			global $wpdb;

			foreach ($new_values as $page_id => $new_value)
			{
				$page_config = $this->get_page_config($page_id);
				if ($page_config === false)
				{
					// No page configuration can be found so use default values
					$page_config = $this->page_config_default_values;
					$this->debug('Using default values for page ' .
								 'configuration of page ID', $page_id);
				}

				$page_config['page_id'] = $page_id;

				$top_left_style = $wpdb->escape($new_value);
				$page_config['top_left_style'] = $top_left_style;

				// Save the values into the database
				if (!$this->update_page_config($page_id, $page_config))
				{
					$this->debug('Unable to update the top left style value ' .
								 'for page ID', $page_id);
				}
			}

			return $old_value;
		}

		function update_option_top_right($new_values, $old_value)
		{
			global $wpdb;

			foreach ($new_values as $page_id => $new_value)
			{
				$page_config = $this->get_page_config($page_id);
				if ($page_config === false)
				{
					// No page configuration can be found so use default values
					$page_config = $this->page_config_default_values;
					$this->debug('Using default values for page ' .
								 'configuration of page ID', $page_id);
				}

				$page_config['page_id'] = $page_id;

				$top_right = intval($wpdb->escape($new_value));
				$page_config['top_right'] = $top_right;

				// Save the values into the database
				if (!$this->update_page_config($page_id, $page_config))
				{
					$this->debug('Unable to update the top right value for ' .
								 'page ID', $page_id);
				}
			}

			return $old_value;
		}

		function update_option_top_right_style($new_values, $old_value)
		{
			global $wpdb;

			foreach ($new_values as $page_id => $new_value)
			{
				$page_config = $this->get_page_config($page_id);
				if ($page_config === false)
				{
					// No page configuration can be found so use default values
					$page_config = $this->page_config_default_values;
					$this->debug('Using default values for page ' .
								 'configuration of page ID', $page_id);
				}

				$page_config['page_id'] = $page_id;

				$top_right_style = $wpdb->escape($new_value);
				$page_config['top_right_style'] = $top_right_style;

				// Save the values into the database
				if (!$this->update_page_config($page_id, $page_config))
				{
					$this->debug('Unable to update the top right style value ' .
								 'for page ID', $page_id);
				}
			}

			return $old_value;
		}

		function update_option_bottom_left($new_values, $old_value)
		{
			global $wpdb;

			foreach ($new_values as $page_id => $new_value)
			{
				$page_config = $this->get_page_config($page_id);
				if ($page_config === false)
				{
					// No page configuration can be found so use default values
					$page_config = $this->page_config_default_values;
					$this->debug('Using default values for page ' .
								 'configuration of page ID', $page_id);
				}

				$page_config['page_id'] = $page_id;

				$bottom_left = intval($wpdb->escape($new_value));
				$page_config['bottom_left'] = $bottom_left;

				// Save the values into the database
				if (!$this->update_page_config($page_id, $page_config))
				{
					$this->debug('Unable to update the bottom_left value for ' .
								 'page ID', $page_id);
				}
			}

			return $old_value;
		}

		function update_option_bottom_left_style($new_values, $old_value)
		{
			global $wpdb;

			foreach ($new_values as $page_id => $new_value)
			{
				$page_config = $this->get_page_config($page_id);
				if ($page_config === false)
				{
					// No page configuration can be found so use default values
					$page_config = $this->page_config_default_values;
					$this->debug('Using default values for page ' .
								 'configuration of page ID', $page_id);
				}

				$page_config['page_id'] = $page_id;

				$bottom_left_style = $wpdb->escape($new_value);
				$page_config['bottom_left_style'] = $bottom_left_style;

				// Save the values into the database
				if (!$this->update_page_config($page_id, $page_config))
				{
					$this->debug('Unable to update the bottom left style ' .
								 'value for page ID', $page_id);
				}
			}

			return $old_value;
		}

		function update_option_bottom_right($new_values, $old_value)
		{
			global $wpdb;

			foreach ($new_values as $page_id => $new_value)
			{
				$page_config = $this->get_page_config($page_id);
				if ($page_config === false)
				{
					// No page configuration can be found so use default values
					$page_config = $this->page_config_default_values;
					$this->debug('Using default values for page ' .
								 'configuration of page ID', $page_id);
				}

				$page_config['page_id'] = $page_id;

				$bottom_right = intval($wpdb->escape($new_value));
				$page_config['bottom_right'] = $bottom_right;

				// Save the values into the database
				if (!$this->update_page_config($page_id, $page_config))
				{
					$this->debug('Unable to update the bottom right value ' .
								 'for page ID', $page_id);
				}
			}

			return $old_value;
		}

		function update_option_bottom_right_style($new_values, $old_value)
		{
			global $wpdb;

			foreach ($new_values as $page_id => $new_value)
			{
				$page_config = $this->get_page_config($page_id);
				if ($page_config === false)
				{
					// No page configuration can be found so use default values
					$page_config = $this->page_config_default_values;
					$this->debug('Using default values for page ' .
								 'configuration of page ID', $page_id);
				}

				$page_config['page_id'] = $page_id;

				$bottom_right_style = $wpdb->escape($new_value);
				$page_config['bottom_right_style'] = $bottom_right_style;

				// Save the values into the database
				if (!$this->update_page_config($page_id, $page_config))
				{
					$this->debug('Unable to update the bottom right style ' .
								 'value for page ID', $page_id);
				}
			}

			return $old_value;
		}

		/**
		 * Retrieves the requested page's page blocks configuration
		 */
		function get_page_config($page_id)
		{
			global $wpdb;

			// First cast the page ID to an integer to ensure that it is safe
			$page_id = (int) $page_id;

			$sql = "SELECT * FROM $this->db_table " .
				   "WHERE page_id = $page_id";
			$page_config = $wpdb->get_row($sql, ARRAY_A);

			// Check to make sure we have something... if not then bail out
			// reporting false for failure
			if (!is_array($page_config))
			{
				$this->debug('Unable to find the page configuration');
				return false;
			}

			return $page_config;
		}

		/**
		 * Updates the page's page blocks configuration information
		 */
		function update_page_config($page_id, $page_config)
		{
			global $wpdb;

			if ((!is_array($page_config)) || (count($page_config) < 1))
			{
				// Page configuration information is not in the correct form
				// so bail out indicating failure
				$this->debug('Page configuration is either invalid or empty');
				return false;
			}

			// Look for an existing entry for this page to determine the correct
			// SQL query to use
			$page_id = (int) $page_id;
			$page_config_exists = ($this->get_page_config($page_id) !== false);

			// Build an appropriate SQL query
			if ($page_config_exists)
			{
				$sql_arr = array();
				$sql = "UPDATE IGNORE $this->db_table SET ";
				foreach ($page_config as $field => $value)
				{
					switch ($field)
					{
						// Numeric Types
						case 'top_left':
						case 'top_right':
						case 'bottom_left':
						case 'bottom_right':
							$sql_arr[] = "$field = $value";
							break;

						// String Types
						case 'top_left_style':
						case 'top_right_style':
						case 'bottom_left_style':
						case 'bottom_right_style':
						case 'widgets':
							$sql_arr[] = "$field = '$value'";
							break;

						default:
							// Any fields not specified above are omitted
							break;
					}
				}

				$sql .= implode(', ', $sql_arr) . " WHERE page_id = $page_id";
			}
			else
			{
				$fields_arr = array();
				$values_arr = array();

				foreach ($page_config as $field => $value)
				{
					switch ($field)
					{
						// Numeric Types
						case 'page_id':
						case 'top_left':
						case 'top_right':
						case 'bottom_left':
						case 'bottom_right':
							$fields_arr[] = "$field";
							$values_arr[] = "$value";
							break;

						// String Types
						case 'top_left_style':
						case 'top_right_style':
						case 'bottom_left_style':
						case 'bottom_right_style':
						case 'widgets':
							$fields_arr[] = "$field";
							$values_arr[] = "'$value'";
							break;

						default:
							// Any fields not specified above are omitted
							break;
					}
				}

				$fields = implode(', ', $fields_arr);
				$values = implode(', ', $values_arr);
				$sql = "INSERT IGNORE INTO $this->db_table ($fields) " .
					   "VALUES ($values)";
			}

			$this->debug("Page configuration update query to be executed:\n",
						 $sql);

			$results = $wpdb->query($sql);
			if ($results != 1)
			{
				// An error has occured while trying to update / insert the page
				// configuration information in the database
				$this->debug('Unable to execute SQL query on database');
				return false;
			}

			return true;
		}

		/**
		 * Delete the page configuration information from the plugin table
		 */
		function admin_delete_page_blocks_config($page_id)
		{
			global $wpdb;

			// First cast the page ID to an integer to make sure it is safe
			$page_id = (int) $page_id;

			$sql = "DELETE IGNORE FROM $this->tablename " .
				   "WHERE page_id = $page_id";
			$results = $wpdb->query($sql);

			$deleted = ($results > 0);
			if ($deleted)
			{
				$this->debug('Page configuration deleted from database for ' .
							 'page ID:', $page_id);
			}
			else
			{
				$this->debug('Page configuration NOT deleted from database ' .
							 'for page ID:', $page_id);
			}

			return $deleted;
		}

		/**
		 * Override WordPress update_option('sidebars_widgets') function calls
		 * to store updates to the page blocks widgets configuration
		 */
		function update_option_sidebars_widgets($old_widgets, $new_widgets)
		{
			// Override update_option('sidebars_widgets') to restore the
			// contents of the 'sidebars_widgets' option in the wp_options
			// table, and disassemble the currently configured widgets in
			// $new_widgets into the configuration applicable to the theme
			// sidebars (which should remain the same across all pages),
			// and the configuration applicable to the page block sidebars
			// (which is unique to the current page).

			global $wpdb;

			// Extract the values that are currently in the
			// pbs_page_block_config table from $old_widgets so we can determine
			// if the contents have changed and whether the
			// pbs_page_block_config table should be updated.

			$pb_old_options = array();
			foreach ($old_widgets as $old_sidebar_id => $old_sidebar)
			{
				if (in_array($old_sidebar_id, $this->registered_sidebars_ids))
				{
					// This is a page block sidebar
					$pb_old_options[$old_sidebar_id] = $old_sidebar;
				}
			}

			// Analyse the $new_widgets contents and separate it into values
			// that should go in the wp_options table and values that should go
			// into the pbs_page_block_config table

			$wp_options = array();
			$pb_options = array();
			foreach ($new_widgets as $sidebar_id => $sidebar)
			{
				if (in_array($sidebar_id, $this->registered_sidebars_ids))
				{
					// This is a page block sidebar
					$pb_options[$sidebar_id] = $sidebar;
				}
				else
				{
					// This is a non page blocks sidebar e.g. theme sidebar
					$wp_options[$sidebar_id] = $sidebar;
				}
			}

			// Now determine if the entry in the pbs_page_block_config table has
			// changed
			$update_pbs_table = false;
			if ($pb_old_options != $pb_options)
			{
				$update_pbs_table = true;
			}

			// Include the 'array_version' key so that it's flagged as being in
			// the latest format
			$wp_options['array_version'] = 3;
			$pb_options['array_version'] = 3;

			// Serialize the array data into a string for insertion into
			// the database
			$wp_options_serialized = maybe_serialize($wp_options);
			$pb_options_serialized = maybe_serialize($pb_options);

			// Update the wp_options table
			// NOTE: This must be done through a direct SQL query since calling
			// update_option() will send the code into an infinite loop
			$wp_options_serialized = $wpdb->escape($wp_options_serialized);
			$sql = "UPDATE $wpdb->options " .
				   "SET option_value = '$wp_options_serialized' " .
				   "WHERE option_name = 'sidebars_widgets'";
			$wpdb->query($sql);

			// Update the configured widgets for the currently selected page in
			// the plugin database table
			if ($update_pbs_table)
			{
//				$page_id = $this->get_page_id();
				// The page ID comes from the plugin's settings since the
				// update_options() function will only ever be called from the
				// admin backend
				$page_id =
					(int) $this->get_plugin_setting(PBS_OPTION_SETTINGS,
													PBS_SETTING_SELECTED_PAGE);
				if ($page_id > 0)
				{
					$new_page_config =
						array('widgets' => $pb_options_serialized);
					$this->update_page_config($page_id, $new_page_config);
				}
			}
		}

		/**
		 * Overrides the WordPress get_option('sidebars_widgets') function to
		 * extract the current configured widgets
		 */
		function get_option_sidebars_widgets($wp_option_value)
		{
			$this->debug('Getting widgets for sidebar');

			// Override get_option('sidebars_widgets') to pull the current
			// configured widgets from both the plugin database table (for the
			// appropriate configuration for the sidebars implementing the
			// page's page blocks) as well as the wp_options table (for the
			// configuration of the sidebar(s) configured by the theme) in order
			// to allow different widgets to be configured for different pages.

			// The value of the 'sidebars_widgets' option stored in the
			// wp_options table is contained in $wp_option_value (unserialised
			// into an array), so now we need to find the value contained in the
			// plugin table for the corresponding page and combine it with the
			// value in the wp_options table.
			$widgets = $wp_option_value;

			$page_id = $this->determine_page_id();
			$this->debug('Getting page blocks sidebars for page', $page_id);

			if ($page_id > 0)
			{
				// Find the configuration for the page (if available)
				$page_config = $this->get_page_config($page_id);
				if (is_array($page_config))
				{
					// $plugin_option_value should now contain the values from
					// the plugin table after it has been unserialised below, so
					// now these need to be combined with the values from the
					// wp_options database table
					$plugin_option_value =
						maybe_unserialize($page_config['widgets']);
					$widgets = array_merge($widgets, $plugin_option_value);
				}
			}

			$this->debug('Found widgets', $widgets);

			return $widgets;
		}

		/**
		 * Indicates whether the plugin is in debug mode
		 */
		function is_debug_mode()
		{
			return ($this->debug_level > 0);
		}

		/**
		 * Writes each parameter to the debug log separated by spaces
		 */
		function debug()
		{
			if (!$this->is_debug_mode())
			{
				return;
			}

			$msg = array();
			$args = func_get_args();
			foreach ($args as $arg)
			{
				if (is_scalar($arg))
				{
					$msg[] = $arg;
				}
				else
				{
					$msg[] = "\n" . print_r($arg, true);// . "\n";
				}
			}

			$msg = join(' ', $msg);
			return $this->write_to_log(PBS_DEBUG_LOG, $msg);
		}

		/**
		 * Generates a single entry in the log file specified
		 */
		function write_to_log($filename, $data,
							  $add_timestamp = true, $create_new = false)
		{
			if (!is_string($data))
			{
				return false;
			}

			// Find the name of the function that is trying to write to the log
			$backtrace = debug_backtrace();
			array_shift($backtrace);
			$caller = array_shift($backtrace);
			if ($caller['function'] == 'debug')
			{
				$caller = array_shift($backtrace);
			}
			$function = (array_key_exists('function', $caller)) ?
							$caller['function'] : '???';
			$line = (array_key_exists('line', $caller)) ? $caller['line'] : '?';

			// Add a timestamp and calculate the length of $data in order to be
			// able to determine if an error occurred while writing to $filename
			$timestamp = date("H:i:s ");
			$glue = "\n" . (($add_timestamp) ? $timestamp : '');
			$data = $glue . $function . '(' . $line . ') - ' . $data;
			$data_len = strlen($data);

			// Now attempt to write $data to $filename
			$bytes = 0;
			$result = false;

			if (!$create_new)
			{
				$file_handle = @fopen($filename, "at");
			}
			else
			{
				$file_handle = @fopen($filename, "wt");
			}

			$bytes = @fwrite($file_handle, $data);
			@fflush($file_handle);
			@fclose($file_handle);

			if ($bytes === false)
			{
				$result = false;
			}
			else if ($bytes == $data_len)
			{
				$result = true;
			}
			else
			{
				$result = false;
			}

			return $result;
		}

		/**
		 * Tests the version of WordPress against the version specified using
		 * the relationship given
		 */
		function is_wordpress_version($version, $relationship)
		{
			global $wp_version;
			$this->debug('WordPress version: ', $wp_version);
			return (version_compare($wp_version, $version, $relationship));
		}

		/**
		 * Works out the correct page ID depending upon where it is called
		 *
		 * @return int The ID of the page if it can be determined
		 */
		function determine_page_id()
		{
			global $wp_query;
			$page_id = -1;

			// This function can be called in two different scenarios:
			//	1. A frontend page is being generated by the main WordPress Loop
			//	2. The plugin is being configured using the admin backend
			if ($this->in_main_loop)
			{
				$this->debug('Looking for page ID in the post information');

				// Scenario 1:
				// This function has been called by the main WordPress Loop, and
				// so the page ID is derived from the page's post information.
				// The method of extracting this information is different for
				// different versions of WordPress
				if ($this->is_wordpress_version('2.7.1', '>'))
				{
					if (count($wp_query->posts) > 0)
					{
						$page_post = $wp_query->posts[0];
						$page_id = $page_post->ID;
					}
				}
				else
				{
					global $post;
					$page_id = $post->ID;
				}
			}
			else
			{
				$this->debug('Getting page ID from plugin settings');

				// Scenario 2:
				// This function has been called from the admin backend Widgets
				// page, and hence the page ID comes from the one that has been
				// selected by the user and is stored in the plugins's settings
				$page_id =
					(int) $this->get_plugin_setting(PBS_OPTION_SETTINGS,
													PBS_SETTING_SELECTED_PAGE);
			}

			return $page_id;
		}

		/**
		 * Saves the post instance and WordPress global post variables
		 */
		function backup_post_data()
		{
			$post_backup = array();
			foreach ($this->wp_post_vars as $var_name)
			{
				if (array_key_exists($var_name, $GLOBALS))
				{
					$post_backup[$var_name] =
						(is_object($GLOBALS[$var_name])) ?
							wp_clone($GLOBALS[$var_name]) :
							$GLOBALS[$var_name];
				}
			}

			return $post_backup;
		}

		/**
		 * Restores the post instance and WordPress global post variables
		 */
		function restore_post_data($post_backup)
		{
			foreach ($post_backup as $var_name => $var_value)
			{
				$GLOBALS[$var_name] =
					(is_object($var_value)) ? wp_clone($var_value) : $var_value;
			}
		}

		/**
		 * Dynamically creates the sidebars for the specified page configuration
		 */
		function register_page_blocks($page_config)
		{
			if ($page_config === false)
			{
				// No page configuration can be found so bail
				$this->debug('Exiting - Configuration information not found');
				return false;
			}

			if (!function_exists('register_sidebar'))
			{
				// Sidebar functionality is not available so abort here
				$this->debug('Exiting - Sidebars not supported');
				return false;
			}

			// First remove all page blocks already registered (if any)
			if (count($this->registered_sidebars_ids) > 0)
			{
				foreach ($this->registered_sidebars_ids as $sidebar_id)
				{
					unregister_sidebar($sidebar_id);
				}

				$this->registered_sidebars_ids = array();
			}

			// Get the information about each page block's WordPress sidebar
			$sidebars = $this->page_blocks_sidebars_info;

			$this->debug('Page Blocks configuration:', $page_config);

			// Register the associated WordPress sidebars for the required page
			// blocks from the information in the page configuration
			if ($page_config['top_left'] == 1)
			{
				$this->registered_sidebars_ids[] =
					register_sidebar(
						array('name' => $sidebars['top_left_name'],
							  'id'   => $sidebars['top_left_id']));
			}

			if ($page_config['top_right'] == 1)
			{
				$this->registered_sidebars_ids[] =
					register_sidebar(
						array('name' => $sidebars['top_right_name'],
							  'id'   => $sidebars['top_right_id']));
			}

			if ($page_config['bottom_left'] == 1)
			{
				$this->registered_sidebars_ids[] =
					register_sidebar(
						array('name' => $sidebars['bottom_left_name'],
							  'id'   => $sidebars['bottom_left_id']));
			}

			if ($page_config['bottom_right'] == 1)
			{
				$this->registered_sidebars_ids[] =
					register_sidebar(
						array('name' => $sidebars['bottom_right_name'],
							  'id'   => $sidebars['bottom_right_id']));
			}

			$this->debug('Page blocks successfully registered');

			return true;
		}
	}
}
?>